<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth Hand Tracking</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        /* ‡∏Å‡∏•‡πà‡∏≠‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡∏°‡∏∏‡∏°‡∏ã‡πâ‡∏≤‡∏¢‡∏•‡πà‡∏≤‡∏á) */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #00ffcc;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            background: #222;
        }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* ‡∏Å‡∏•‡∏±‡∏ö‡∏î‡πâ‡∏≤‡∏ô‡∏Å‡∏£‡∏∞‡∏à‡∏Å‡πÄ‡∏á‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏á‡πà‡∏≤‡∏¢ */
        }

        /* ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Loading */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            font-size: 24px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ffcc;
            pointer-events: none;
            z-index: 20;
        }

        /* Instruction overlay */
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 15;
        }
        h3 { margin: 0 0 10px 0; color: #00ffcc; }
        p { margin: 5px 0; font-size: 14px; }
    </style>
    
    <!-- Import Libraries -->
    <!-- Three.js ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏ö‡∏°‡∏∑‡∏≠ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• AI...<br><span style="font-size:16px; color:#aaa;">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á</span></div>
    
    <div id="instructions">
        <h3>‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°</h3>
        <p>üñê <b>‡∏Ç‡∏¢‡∏±‡∏ö‡∏°‡∏∑‡∏≠:</b> ‡∏´‡∏°‡∏∏‡∏ô‡πÇ‡∏•‡∏Å</p>
        <p>üëå <b>‡∏à‡∏µ‡∏ö‡∏ô‡∏¥‡πâ‡∏ß (‡πÇ‡∏õ‡πâ‡∏á-‡∏ä‡∏µ‡πâ):</b> ‡∏ã‡∏π‡∏°‡πÄ‡∏Ç‡πâ‡∏≤-‡∏≠‡∏≠‡∏Å</p>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <script>
        // ==========================================
        // ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏•‡∏Å 3D ‡∏î‡πâ‡∏ß‡∏¢ Three.js
        // ==========================================
        const scene = new THREE.Scene();
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏î‡∏≤‡∏ß‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (Stars)
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({color: 0xffffff});
        const starVertices = [];
        for(let i=0; i<5000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starVertices.push(x,y,z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏π‡∏Å‡πÇ‡∏•‡∏Å (Sphere)
        const earthGeometry = new THREE.SphereGeometry(2, 64, 64);
        
        // --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Texture ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡∏Å‡∏£‡∏ì‡∏µ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ) ---
        function createFallbackTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // ‡∏û‡∏∑‡πâ‡∏ô‡∏°‡∏´‡∏≤‡∏™‡∏°‡∏∏‡∏ó‡∏£
            ctx.fillStyle = '#1a237e'; 
            ctx.fillRect(0, 0, 512, 512);
            
            // ‡∏ß‡∏≤‡∏î‡πÅ‡∏ú‡πà‡∏ô‡∏î‡∏¥‡∏ô‡∏à‡∏≥‡∏•‡∏≠‡∏á (Random blobs)
            ctx.fillStyle = '#2e7d32'; 
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const r = 30 + Math.random() * 80;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ‡πÄ‡∏™‡πâ‡∏ô Grid ‡∏ö‡∏≤‡∏á‡πÜ
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 2;
            for(let i=0; i<512; i+=64){
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 512); ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        }

        const textureLoader = new THREE.TextureLoader();
        textureLoader.setCrossOrigin('anonymous'); // ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏Ç‡πâ‡∏≤‡∏°‡πÇ‡∏î‡πÄ‡∏°‡∏ô

        // ‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ Blue Marble (‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏Å‡∏ß‡πà‡∏≤)
        const textureUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Blue_Marble_2002.png/1024px-Blue_Marble_2002.png';

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á Material ‡∏£‡∏≠‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô (‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à)
        const earthMaterial = new THREE.MeshPhongMaterial({
            color: 0x112244,
            specular: new THREE.Color('grey'),
            shininess: 10
        });

        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
        textureLoader.load(
            textureUrl,
            // Success
            function (texture) {
                console.log('Texture loaded successfully');
                earth.material.map = texture;
                earth.material.color.setHex(0xffffff); // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Texture ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                earth.material.needsUpdate = true;
            },
            // Progress
            undefined,
            // Error
            function (err) {
                console.warn('Texture failed to load, using procedural fallback.', err);
                // ‡πÉ‡∏ä‡πâ Texture ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å Canvas ‡πÅ‡∏ó‡∏ô
                earth.material.map = createFallbackTexture();
                earth.material.color.setHex(0xffffff);
                earth.material.needsUpdate = true;
            }
        );

        // ‡πÅ‡∏™‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á
        const ambientLight = new THREE.AmbientLight(0x555555);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(5, 3, 5);
        scene.add(directionalLight);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(-5, -3, -10);
        scene.add(backLight);

        // ‡πÄ‡∏°‡∏Ü (‡∏™‡∏£‡πâ‡∏≤‡∏á Sphere ‡∏≠‡∏µ‡∏Å‡∏ä‡∏±‡πâ‡∏ô)
        const cloudGeometry = new THREE.SphereGeometry(2.05, 64, 64);
        const cloudMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff, 
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
        scene.add(clouds);

        camera.position.z = 6;

        // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Smooth Animation
        let targetRotationX = 0;
        let targetRotationY = 0;
        let targetZoom = 6;
        let isHandDetected = false;

        // ==========================================
        // ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 2: MediaPipe Hands (AI ‡∏à‡∏±‡∏ö‡∏°‡∏∑‡∏≠)
        // ==========================================
        const videoElement = document.getElementById('input_video');
        const loadingElement = document.getElementById('loading');

        function onResults(results) {
            if (loadingElement.style.display !== 'none') {
                loadingElement.style.display = 'none';
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. ‡∏´‡∏°‡∏∏‡∏ô (‡πÉ‡∏ä‡πâ‡∏ù‡πà‡∏≤‡∏°‡∏∑‡∏≠)
                const palmX = landmarks[9].x;
                const palmY = landmarks[9].y;

                targetRotationY = (palmX - 0.5) * Math.PI * 2; 
                targetRotationX = (palmY - 0.5) * Math.PI * 1.5;

                // 2. ‡∏ã‡∏π‡∏° (‡πÉ‡∏ä‡πâ‡∏ô‡∏¥‡πâ‡∏ß‡πÇ‡∏õ‡πâ‡∏á-‡∏ä‡∏µ‡πâ)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDistance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const minZoom = 2.5;
                const maxZoom = 9.0;
                targetZoom = 2.5 + (pinchDistance * 15);
                
                if(targetZoom < minZoom) targetZoom = minZoom;
                if(targetZoom > maxZoom) targetZoom = maxZoom;

            } else {
                isHandDetected = false;
                // ‡∏´‡∏°‡∏∏‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏°‡∏∑‡∏≠
                targetRotationY += 0.002;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();


        // ==========================================
        // ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 3: Main Animation Loop
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);

            if(isHandDetected) {
                earth.rotation.y += (targetRotationY - earth.rotation.y) * 0.05;
                earth.rotation.x += (targetRotationX - earth.rotation.x) * 0.05;
                clouds.rotation.y += (targetRotationY - clouds.rotation.y) * 0.06;
                clouds.rotation.x += (targetRotationX - clouds.rotation.x) * 0.06;

                camera.position.z += (targetZoom - camera.position.z) * 0.1;
            } else {
                earth.rotation.y += 0.002;
                clouds.rotation.y += 0.0025;
                camera.position.z += (6 - camera.position.z) * 0.05;
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
